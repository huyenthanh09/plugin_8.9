// (C) 2022 GoodData Corporation
import { __assign } from "tslib";
import { isNonEmptyListItem } from "../../AttributeDropdown/types";
import { useCallback, useEffect, useState } from "react";
import { ATTRIBUTE_FILTER_BUTTON_LIMIT } from "../constants";
import { checkFilterSetupForBackend, getInitialIsInverted, getInitialSelectedOptions, } from "../AttributeFilterButtonUtils";
import isEqual from "lodash/isEqual";
import { mergeElementQueryResults } from "../../AttributeDropdown/mergeElementQueryResults";
import { updateSelectedOptionsWithDataByMap } from "../../utils/AttributeFilterUtils";
import compact from "lodash/compact";
import debounce from "lodash/debounce";
/**
 * Provides a {@link IAttributeFilterButtonState} and a set of functions to handle the state
 * of {@link AttributeFilterButton} component.
 *
 * @param currentFilter - the filter object to initialize the component's state.
 */
export var useAttributeFilterButtonState = function (currentFilter, backend) {
    /**
     * AttributeFilterButton state initialization
     */
    var _a = useState(function () {
        checkFilterSetupForBackend(currentFilter, backend);
        var initialSelection = getInitialSelectedOptions(currentFilter);
        var initialIsInverted = getInitialIsInverted(currentFilter);
        return {
            selectedFilterOptions: initialSelection,
            appliedFilterOptions: initialSelection,
            isInverted: initialIsInverted,
            appliedIsInverted: initialIsInverted,
            firstLoad: true,
            searchString: "",
            offset: 0,
            limit: ATTRIBUTE_FILTER_BUTTON_LIMIT,
            isDropdownOpen: false,
            validOptions: null,
            uriToAttributeElementMap: new Map(),
            isFiltering: false,
            needsReloadAfterSearch: false,
        };
    }), state = _a[0], setState = _a[1];
    var onCurrentFilterChange = function (currentFilter) {
        setState(function (prevValue) {
            var initialSelection = getInitialSelectedOptions(currentFilter);
            var initialIsInverted = getInitialIsInverted(currentFilter);
            // todo check if there is need to handle values here
            var selectedOptionsUris = prevValue.selectedFilterOptions.map(function (opt) { return opt.uri; });
            var appliedOptionsUris = prevValue.appliedFilterOptions.map(function (opt) { return opt.uri; });
            var initialSelectionUris = initialSelection.map(function (opt) { return opt.uri; });
            var resultState = prevValue;
            if (!isEqual(selectedOptionsUris, initialSelectionUris)) {
                resultState = __assign(__assign({}, resultState), { selectedFilterOptions: initialSelection });
            }
            if (!isEqual(appliedOptionsUris, initialSelectionUris)) {
                resultState = __assign(__assign({}, resultState), { appliedFilterOptions: initialSelection });
            }
            if (prevValue.isInverted !== initialIsInverted) {
                resultState = __assign(__assign({}, resultState), { isInverted: initialIsInverted, appliedIsInverted: initialIsInverted });
            }
            // if no change returning prevValue effectively skips the setState
            return resultState;
        });
    };
    var clearUriToElementMap = function () {
        setState(function (prevState) {
            return __assign(__assign({}, prevState), { uriToAttributeElementMap: new Map() });
        });
    };
    var resetSelection = function () {
        setState(function (prevState) {
            return __assign(__assign({}, prevState), { selectedFilterOptions: [], appliedFilterOptions: [], isInverted: true, appliedIsInverted: true, validOptions: null, isFiltering: true });
        });
    };
    var mapInitialSelectionElements = function (initialElements, isElementsByRef) {
        setState(function (prevState) {
            var _a;
            var uriToAttributeElementMap = new Map(prevState.uriToAttributeElementMap);
            (_a = initialElements.items) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {
                var key = isElementsByRef ? item.uri : item.title;
                uriToAttributeElementMap.set(key, item);
            });
            return __assign(__assign({}, prevState), { uriToAttributeElementMap: uriToAttributeElementMap });
        });
    };
    var resolveAttributeElements = function (elements, parentFilters, isElementsByRef) {
        setState(function (prevState) {
            var mergedValidElements = mergeElementQueryResults(prevState.validOptions, elements);
            var newUriToAttributeElementMap = new Map(prevState.uriToAttributeElementMap);
            var items = mergedValidElements.items;
            items.filter(isNonEmptyListItem).forEach(function (item) {
                var key = isElementsByRef ? item.uri : item.title;
                newUriToAttributeElementMap.set(key, item);
            });
            // make sure that selected items have both title and uri, otherwise selection in InvertableList won't work
            // TODO we could maybe use the InvertableList's getItemKey and just use title or uri for example
            var updatedSelectedItems = updateSelectedOptionsWithDataByMap(prevState.selectedFilterOptions, newUriToAttributeElementMap, isElementsByRef);
            var updatedAppliedItems = updateSelectedOptionsWithDataByMap(prevState.appliedFilterOptions, newUriToAttributeElementMap, isElementsByRef);
            var validOptions = (parentFilters === null || parentFilters === void 0 ? void 0 : parentFilters.length) ? elements : mergedValidElements;
            return __assign(__assign({}, prevState), { selectedFilterOptions: compact(updatedSelectedItems), appliedFilterOptions: compact(updatedAppliedItems), validOptions: validOptions, firstLoad: false, uriToAttributeElementMap: newUriToAttributeElementMap, needsReloadAfterSearch: false });
        });
    };
    var onSearch = useCallback(debounce(function (query) {
        setState(function (s) { return (__assign(__assign({}, s), { searchString: query })); });
    }, 500), []);
    var onElementSelect = function (selectedFilterOptions, isInverted) {
        setState(function (s) { return (__assign(__assign({}, s), { selectedFilterOptions: selectedFilterOptions, isInverted: isInverted })); });
    };
    var backupIsInverted = function () {
        setState(function (state) { return (__assign(__assign({}, state), { appliedIsInverted: state.isInverted })); });
    };
    var removeFilteringStatus = function () {
        setState(function (prevState) {
            return __assign(__assign({}, prevState), { isFiltering: false });
        });
    };
    var onRangeChange = function (_searchString, from, to) {
        // only react to range changes after initial load to properly handle offset shifts on search
        if (state.validOptions) {
            setState(function (s) { return (__assign(__assign({}, s), { offset: from, limit: to - from })); });
        }
    };
    var onDropdownClosed = function () {
        setState(function (s) {
            return __assign(__assign({}, s), { selectedFilterOptions: s.appliedFilterOptions, isInverted: s.appliedIsInverted, searchString: "", isDropdownOpen: false });
        });
    };
    var onDropdownOpen = function () {
        setState(function (s) { return (__assign(__assign({}, s), { isDropdownOpen: true })); });
    };
    /**
     * Effects
     */
    useEffect(function () {
        setState(function (prevState) {
            return __assign(__assign({}, prevState), { validOptions: null, offset: 0, limit: ATTRIBUTE_FILTER_BUTTON_LIMIT, needsReloadAfterSearch: true });
        });
    }, [state.searchString]);
    return {
        state: state,
        onCurrentFilterChange: onCurrentFilterChange,
        clearUriToElementMap: clearUriToElementMap,
        resetSelection: resetSelection,
        mapInitialSelectionElements: mapInitialSelectionElements,
        resolveAttributeElements: resolveAttributeElements,
        onSearch: onSearch,
        onElementSelect: onElementSelect,
        backupIsInverted: backupIsInverted,
        removeFilteringStatus: removeFilteringStatus,
        onRangeChange: onRangeChange,
        onDropdownClosed: onDropdownClosed,
        onDropdownOpen: onDropdownOpen,
    };
};
//# sourceMappingURL=useAttributeFilterButtonState.js.map