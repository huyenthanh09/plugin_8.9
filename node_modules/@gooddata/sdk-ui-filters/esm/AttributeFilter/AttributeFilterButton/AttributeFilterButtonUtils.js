import { attributeElementsToAttributeElementArray, getAllExceptTitle, getAllTitle, getFilteringTitleIntl, getItemsTitles, getLoadingTitleIntl, getNoneTitleIntl, getObjRef, } from "../utils/AttributeFilterUtils";
import { filterAttributeElements, isAttributeElementsByRef, isNegativeAttributeFilter, newNegativeAttributeFilter, newPositiveAttributeFilter, } from "@gooddata/sdk-model";
import isEmpty from "lodash/isEmpty";
import isNil from "lodash/isNil";
/**
 * Gets the selection from the initial {@link @gooddata/sdk-model#IAttributeFilter} object.
 */
export var getInitialSelectedOptions = function (currentFilter) {
    // the as any cast is ok here, the data will get fixed once the element load completes
    // this serves only to have some initial state here so that when full element data is loaded
    // it automatically sets the props.filter.elements as selected
    return currentFilter
        ? attributeElementsToAttributeElementArray(filterAttributeElements(currentFilter))
        : [];
};
/**
 * Gets the isInverted property from the initial {@link @gooddata/sdk-model#IAttributeFilter} object.
 */
export var getInitialIsInverted = function (currentFilter) {
    return currentFilter ? isNegativeAttributeFilter(currentFilter) : true;
};
export var isCancelablePromisePending = function (cancelablePromiseStatus) {
    return cancelablePromiseStatus === "pending";
};
export var isCancelablePromiseLoading = function (cancelablePromiseStatus) {
    return cancelablePromiseStatus === "loading";
};
export var isCancelablePromisePendingOrLoading = function (cancelablePromiseStatus) {
    return (isCancelablePromiseLoading(cancelablePromiseStatus) ||
        isCancelablePromisePending(cancelablePromiseStatus));
};
/**
 * Applies a telemetry to the {@link @gooddata/sdk-backend-spi#IAnalyticalBackend} object.
 */
export var getBackend = function (backend, props) {
    return backend.withTelemetry("AttributeFilter", props);
};
/**
 * Creates the new {@link @gooddata/sdk-model#IAttributeFilter} with the actual selection
 * and actual inverted state property.
 */
export var createFilter = function (filter, isInverted, selectedFilterOptions, identifier, emptyFilter) {
    if (emptyFilter === void 0) { emptyFilter = false; }
    var useUriElements = filter && isAttributeElementsByRef(filterAttributeElements(filter));
    var filterFactory = isInverted || emptyFilter ? newNegativeAttributeFilter : newPositiveAttributeFilter;
    var items = emptyFilter ? [] : selectedFilterOptions;
    return filterFactory(getObjRef(filter, identifier), useUriElements
        ? { uris: items.map(function (item) { return item.uri; }) }
        : { values: items.map(function (item) { return item.title; }) });
};
/**
 * Returns number of selected elements. If the selection is inverted, it returns
 * the number of all elements of the attribute without the actual selection,
 * the size of the actual selection otherwise.
 */
export var getNumberOfSelectedItems = function (originalTotalCount, filterOptions, isInverted) {
    if (isInverted) {
        return originalTotalCount - filterOptions.length;
    }
    return filterOptions.length;
};
/**
 * Gets the subtitle according to current selection and loading status of the component.
 */
export var getSubtitle = function (props) {
    var loadingProps = props.loadingProps, ownProps = props.ownProps, state = props.state;
    if (loadingProps.isElementsLoading && !isEmpty(state.searchString)) {
        return "";
    }
    if (loadingProps.isTotalCountLoading) {
        if (state.firstLoad) {
            return getLoadingTitleIntl(ownProps.intl);
        }
        else if (state.isFiltering) {
            return getFilteringTitleIntl(ownProps.intl);
        }
    }
    if (ownProps.isAllFiltered) {
        return getAllTitle(ownProps.intl);
    }
    var displayForm = getObjRef(ownProps.currentFilter, ownProps.identifier);
    if (state.uriToAttributeElementMap.size > 0 && !isNil(ownProps.originalTotalCount) && displayForm) {
        /**
         * If the attribute filter is positive, `getNumberOfSelectedItems` returns current size of
         * the `selectedFilterOptions` array. If the filter is negative attribute filter, it
         * returns difference between `originalTotalCount` and current size of the selection.
         *
         * If the number of selected items is 0 and originalTotalCount is greater than 0, it is
         * considered the selection is empty.
         */
        var empty = getNumberOfSelectedItems(ownProps.originalTotalCount, state.selectedFilterOptions, state.isInverted) === 0 && ownProps.originalTotalCount > 0;
        /**
         * All items are selected only in case the number of selected items is equal to original total
         * count.
         */
        var all = getNumberOfSelectedItems(ownProps.originalTotalCount, state.selectedFilterOptions, state.isInverted) === ownProps.originalTotalCount;
        var getAllPartIntl = all ? getAllTitle(ownProps.intl) : getAllExceptTitle(ownProps.intl);
        if (empty) {
            return getNoneTitleIntl(ownProps.intl);
        }
        if (all) {
            return getAllPartIntl;
        }
        return state.isInverted
            ? getAllPartIntl + " " + getItemsTitles(state.selectedFilterOptions, state.uriToAttributeElementMap, ownProps.isElementsByRef)
            : "" + getItemsTitles(state.selectedFilterOptions, state.uriToAttributeElementMap, ownProps.isElementsByRef);
    }
    return "";
};
export var checkFilterSetupForBackend = function (filter, backend) {
    var isSupportElementUris = backend.capabilities.supportsElementUris;
    var isElementsByRef = isAttributeElementsByRef(filterAttributeElements(filter));
    if (isSupportElementUris && !isElementsByRef) {
        // eslint-disable-next-line no-console
        console.error("The attribute elements must be defined by URIs for this backend.");
    }
};
//# sourceMappingURL=AttributeFilterButtonUtils.js.map