import { __assign } from "tslib";
// (C) 2021-2022 GoodData Corporation
import React, { useEffect, useMemo } from "react";
import { injectIntl } from "react-intl";
import { filterAttributeElements, filterObjRef, isAttributeElementsByRef, } from "@gooddata/sdk-model";
import isEmpty from "lodash/isEmpty";
import isEqual from "lodash/isEqual";
import { IntlWrapper, usePlaceholder, usePrevious, useResolveValueWithPlaceholders, withContexts, } from "@gooddata/sdk-ui";
import { getLoadingTitleIntl, showAllFilteredMessage, showItemsFilteredMessage, } from "./utils/AttributeFilterUtils";
import invariant from "ts-invariant";
import stringify from "json-stable-stringify";
import { useAttributeFilterButtonState } from "./AttributeFilterButton/hooks/useAttributeFilterButtonState";
import { ATTRIBUTE_FILTER_BUTTON_LIMIT } from "./AttributeFilterButton/constants";
import AttributeFilterButtonDefaultError from "./AttributeFilterButton/components/AttributeFilterButtonDefaultError";
import { useAttributeFilterButtonTotalCount } from "./AttributeFilterButton/hooks/useAttributeFilterButtonTotalCount";
import { useParentFilterTitles } from "./AttributeFilterButton/hooks/useParentFilterTitles";
import { useLoadMissingData } from "./AttributeFilterButton/hooks/useLoadMissingData";
import { createFilter, getBackend, getNumberOfSelectedItems, getSubtitle, isCancelablePromiseLoading, isCancelablePromisePendingOrLoading, } from "./AttributeFilterButton/AttributeFilterButtonUtils";
import { useFetchInitialElements } from "./AttributeFilterButton/hooks/useFetchInitialElements";
import { useOriginalTotalElementsCount } from "./AttributeFilterButton/hooks/useOriginalTotalElementsCount";
import { useAttribute } from "./AttributeFilterButton/hooks/useAttribute";
import { useOnErrorCallback } from "./AttributeFilterButton/hooks/useOnErrorCallback";
import AttributeFilterButtonDropdown from "./AttributeFilterButton/components/AttributeFilterButtonDropdown";
export var AttributeFilterButtonCore = function (props) {
    var _a, _b, _c, _d, _e, _f, _g;
    invariant(!(props.filter && props.connectToPlaceholder), "It's not possible to combine 'filter' property with 'connectToPlaceholder' property. Either provide a value, or a placeholder.");
    invariant(!(props.filter && !props.onApply), "It's not possible to use 'filter' property without 'onApply' property. Either provide 'onApply' callback or use placeholders.");
    var _h = usePlaceholder(props.connectToPlaceholder), resolvedPlaceholder = _h[0], setPlaceholderValue = _h[1];
    var currentFilter = resolvedPlaceholder || props.filter;
    var filterRef = filterObjRef(currentFilter);
    var isElementsByRef = isAttributeElementsByRef(filterAttributeElements(currentFilter));
    var currentFilterObjRef = useMemo(function () { return filterRef; }, [stringify(filterRef)]);
    var backendWithTelemetry = useMemo(function () { return getBackend(props.backend, props); }, [props.backend]);
    var _j = useAttributeFilterButtonState(currentFilter, backendWithTelemetry), state = _j.state, onCurrentFilterChange = _j.onCurrentFilterChange, clearUriToElementMap = _j.clearUriToElementMap, resetSelection = _j.resetSelection, mapInitialSelectionElements = _j.mapInitialSelectionElements, resolveAttributeElements = _j.resolveAttributeElements, onSearch = _j.onSearch, onElementSelect = _j.onElementSelect, backupIsInverted = _j.backupIsInverted, removeFilteringStatus = _j.removeFilteringStatus, onRangeChange = _j.onRangeChange, onDropdownClosed = _j.onDropdownClosed, onDropdownOpen = _j.onDropdownOpen;
    var resolvedParentFilters = useResolveValueWithPlaceholders(props.parentFilters);
    var prevParentFilters = usePrevious(resolvedParentFilters);
    useEffect(function () {
        clearUriToElementMap();
    }, [props.backend, props.workspace, props.identifier, stringify(currentFilterObjRef)]);
    useEffect(function () {
        onCurrentFilterChange(currentFilter);
    }, [currentFilter]);
    useEffect(function () {
        if (!isEmpty(props.parentFilters) && !isEqual(prevParentFilters, resolvedParentFilters)) {
            resetSelection();
        }
    }, [stringify(resolvedParentFilters)]);
    var _k = useAttribute({
        backend: backendWithTelemetry,
        workspace: props.workspace,
        identifier: props.identifier,
        filter: currentFilter,
    }), attributeError = _k.error, attribute = _k.result, attributeStatus = _k.status;
    /**
     * This cancelable promise is used to fetch attribute filter elements for the initial selected options or
     * to fetch the elements after selection change coming from the parent component.
     * It's only called on component mounting to ensure we have attribute element titles for elements out of
     * limits in case of huge element number.
     */
    var uriToAttributeElementMapError = useFetchInitialElements({
        context: {
            backend: backendWithTelemetry,
            workspace: props.workspace,
            identifier: props.identifier,
            filter: currentFilter,
        },
        state: {
            selectedFilterOptions: state.selectedFilterOptions,
            appliedFilterOptions: state.appliedFilterOptions,
        },
        isElementsByRef: isElementsByRef,
        onFetchInitialElementsSuccess: mapInitialSelectionElements,
    }).error;
    /**
     * This cancelable promise loads missing page of data if needed and in the onSuccess callback
     * it merges the newly loaded data into the already loaded data
     */
    var _l = useLoadMissingData({
        context: {
            backend: backendWithTelemetry,
            workspace: props.workspace,
            filterObjRef: currentFilterObjRef,
        },
        state: {
            validOptions: state.validOptions,
            offset: state.offset,
            limit: state.limit,
            needsReloadAfterSearch: state.needsReloadAfterSearch,
            searchString: state.searchString,
            selectedFilterOptions: state.selectedFilterOptions,
            appliedFilterOptions: state.appliedFilterOptions,
        },
        ownProps: {
            parentFilters: resolvedParentFilters,
            parentFilterOverAttribute: props.parentFilterOverAttribute,
            isElementsByRef: isElementsByRef,
        },
        onLoadMissingDataSuccess: resolveAttributeElements,
    }), elementsError = _l.error, elementsStatus = _l.status;
    var _m = useOriginalTotalElementsCount({
        context: {
            backend: backendWithTelemetry,
            workspace: props.workspace,
            identifier: props.identifier,
            filter: currentFilter,
        },
        ownProps: {
            parentFilters: resolvedParentFilters,
            parentFilterOverAttribute: props.parentFilterOverAttribute,
        },
    }), originalTotalCountError = _m.error, originalTotalCount = _m.result, originalTotalCountStatus = _m.status;
    useEffect(function () {
        if (!isCancelablePromisePendingOrLoading(originalTotalCountStatus)) {
            removeFilteringStatus();
        }
    }, [originalTotalCountStatus]);
    var _o = useAttributeFilterButtonTotalCount({
        context: {
            backend: backendWithTelemetry,
            workspace: props.workspace,
            filter: currentFilter,
            identifier: props.identifier,
        },
        state: {
            searchString: state.searchString,
        },
        ownProps: {
            parentFilters: resolvedParentFilters,
            parentFilterOverAttribute: props.parentFilterOverAttribute,
        },
    }), totalCountError = _o.error, totalCount = _o.result, totalCountStatus = _o.status;
    var _p = useParentFilterTitles({
        context: {
            backend: backendWithTelemetry,
            workspace: props.workspace,
        },
        ownProps: { parentFilters: resolvedParentFilters },
    }), parentFilterTitlesError = _p.error, parentFilterTitles = _p.result, parentFilterTitlesStatus = _p.status;
    useOnErrorCallback(props.onError, [
        attributeError,
        elementsError,
        totalCountError,
        parentFilterTitlesError,
        originalTotalCountError,
        uriToAttributeElementMapError,
    ]);
    var isAllFiltered = showAllFilteredMessage(isCancelablePromiseLoading(elementsStatus), resolvedParentFilters, originalTotalCount);
    var onApply = function (closeDropdown) {
        var _a;
        backupIsInverted();
        var filter = createFilter(currentFilter, state.isInverted, state.selectedFilterOptions, props.identifier);
        if (props.connectToPlaceholder) {
            setPlaceholderValue(filter);
        }
        (_a = props.onApply) === null || _a === void 0 ? void 0 : _a.call(props, filter, state.isInverted);
        return closeDropdown();
    };
    var onDropdownOpenStateChanged = function (isOpen) {
        isOpen ? onDropdownOpen() : onDropdownClosed();
    };
    var hasNoData = !isCancelablePromisePendingOrLoading(parentFilterTitlesStatus) &&
        !(parentFilterTitles === null || parentFilterTitles === void 0 ? void 0 : parentFilterTitles.length) &&
        !isCancelablePromiseLoading(elementsStatus) &&
        originalTotalCount === 0;
    var getDropdownBodyProps = function (onApplyButtonClicked, onCloseButtonClicked, isMobile) {
        var _a, _b, _c;
        return ({
            items: (_b = (_a = state.validOptions) === null || _a === void 0 ? void 0 : _a.items) !== null && _b !== void 0 ? _b : [],
            totalCount: totalCount !== null && totalCount !== void 0 ? totalCount : ATTRIBUTE_FILTER_BUTTON_LIMIT,
            onSelect: onElementSelect,
            onRangeChange: onRangeChange,
            onSearch: onSearch,
            selectedItems: state.selectedFilterOptions,
            isInverted: state.isInverted,
            isLoading: (!((_c = state.validOptions) === null || _c === void 0 ? void 0 : _c.items) && isCancelablePromiseLoading(elementsStatus)) ||
                [totalCountStatus, originalTotalCountStatus, parentFilterTitlesStatus].some(isCancelablePromisePendingOrLoading),
            searchString: state.searchString,
            applyDisabled: getNumberOfSelectedItems(originalTotalCount, state.selectedFilterOptions, state.isInverted) === 0,
            showItemsFilteredMessage: showItemsFilteredMessage(isCancelablePromiseLoading(elementsStatus), resolvedParentFilters) &&
                !isAllFiltered,
            parentFilterTitles: parentFilterTitles,
            onApplyButtonClicked: onApplyButtonClicked,
            onCloseButtonClicked: onCloseButtonClicked,
            isFullWidth: isMobile,
        });
    };
    var FilterError = props.FilterError;
    return elementsError ||
        attributeError ||
        totalCountError ||
        parentFilterTitlesError ||
        originalTotalCountError ||
        uriToAttributeElementMapError ? (React.createElement(FilterError, { error: (_f = (_e = (_d = (_c = (_b = (_a = elementsError === null || elementsError === void 0 ? void 0 : elementsError.message) !== null && _a !== void 0 ? _a : attributeError === null || attributeError === void 0 ? void 0 : attributeError.message) !== null && _b !== void 0 ? _b : totalCountError === null || totalCountError === void 0 ? void 0 : totalCountError.message) !== null && _c !== void 0 ? _c : parentFilterTitlesError === null || parentFilterTitlesError === void 0 ? void 0 : parentFilterTitlesError.message) !== null && _d !== void 0 ? _d : originalTotalCountError === null || originalTotalCountError === void 0 ? void 0 : originalTotalCountError.message) !== null && _e !== void 0 ? _e : uriToAttributeElementMapError === null || uriToAttributeElementMapError === void 0 ? void 0 : uriToAttributeElementMapError.message) !== null && _f !== void 0 ? _f : "Unknown error" })) : (React.createElement(AttributeFilterButtonDropdown, { isFiltering: state.isFiltering, isDropdownOpen: state.isDropdownOpen, isElementsLoading: !((_g = state.validOptions) === null || _g === void 0 ? void 0 : _g.items) && isCancelablePromiseLoading(elementsStatus), isOriginalTotalCountLoading: isCancelablePromisePendingOrLoading(originalTotalCountStatus), title: props.title || !isCancelablePromisePendingOrLoading(attributeStatus)
            ? attribute.title
            : getLoadingTitleIntl(props.intl), subtitle: getSubtitle({
            loadingProps: {
                isElementsLoading: isCancelablePromiseLoading(elementsStatus),
                isTotalCountLoading: isCancelablePromisePendingOrLoading(totalCountStatus),
            },
            ownProps: {
                isAllFiltered: isAllFiltered,
                isElementsByRef: isElementsByRef,
                currentFilter: currentFilter,
                identifier: props.identifier,
                originalTotalCount: originalTotalCount,
                intl: props.intl,
            },
            state: {
                firstLoad: state.firstLoad,
                isFiltering: state.isFiltering,
                isInverted: state.isInverted,
                selectedFilterOptions: state.selectedFilterOptions,
                uriToAttributeElementMap: state.uriToAttributeElementMap,
                searchString: state.searchString,
            },
        }), selectedFilterOptions: state.selectedFilterOptions, onDropdownOpenStateChanged: onDropdownOpenStateChanged, onApplyButtonClicked: onApply, isAllFiltered: isAllFiltered, hasNoData: hasNoData, getDropdownBodyProps: getDropdownBodyProps, renderBody: props.renderBody }));
};
AttributeFilterButtonCore.defaultProps = {
    FilterError: AttributeFilterButtonDefaultError,
};
var IntlAttributeFilterButton = withContexts(injectIntl(AttributeFilterButtonCore));
/**
 * @public
 */
export var AttributeFilterButton = function (props) {
    return (React.createElement(IntlWrapper, { locale: props.locale },
        React.createElement(IntlAttributeFilterButton, __assign({}, props))));
};
//# sourceMappingURL=AttributeFilterButton.js.map